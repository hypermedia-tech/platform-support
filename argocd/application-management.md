# ArgoCD Application Management

This guide covers common operations and best practices for managing Applications and ApplicationSets in ArgoCD.

## Overview

ArgoCD is a declarative, GitOps continuous delivery tool for Kubernetes. It uses two key custom resources:

- **Applications**: Define a single application to be deployed
- **ApplicationSets**: Generate multiple Applications based on templates

This guide focuses on common management tasks, troubleshooting, and operational procedures.

## Common Operations

### Viewing Applications

```bash
# List all applications
kubectl get applications -n argocd

# View detailed application status
kubectl get application <app-name> -n argocd -o yaml

# Get sync status of all applications
kubectl get applications -n argocd -o jsonpath='{range .items[*]}{.metadata.name}{": "}{.status.sync.status}{"\n"}{end}'
```

### Managing Applications

```bash
# Patch an application to change sync policy
kubectl patch application <app-name> -n argocd --type=merge -p '{"spec":{"syncPolicy":{"automated":{"prune":true,"selfHeal":true}}}}'

# Annotate an application
kubectl annotate application <app-name> -n argocd example.com/annotation-key="annotation-value"

# Delete an application (and its resources if cascade is true)
kubectl delete application <app-name> -n argocd --cascade=true
```

### Working with ApplicationSets

```bash
# List all ApplicationSets
kubectl get applicationsets -n argocd

# View ApplicationSet details
kubectl get applicationset <appset-name> -n argocd -o yaml

# See which Applications are generated by an ApplicationSet
kubectl get applications -n argocd -l argocd.argoproj.io/instance=<appset-name>
```

## Troubleshooting Stuck Applications

### Application Won't Delete

If an application is stuck in deletion, it may have a finalizer preventing cleanup:

```bash
# Check for finalizers
kubectl get application <app-name> -n argocd -o jsonpath='{.metadata.finalizers}'

# Remove the ArgoCD finalizer
kubectl patch application <app-name> -n argocd --type='json' -p='[{"op":"remove","path":"/metadata/finalizers"}]'
```

### Fixing ApplicationSet Issues

If ApplicationSets are stuck or not generating applications correctly:

```bash
# Restart the ApplicationSet controller
kubectl rollout restart deployment argocd-applicationset-controller -n argocd

# Remove finalizers from an ApplicationSet
kubectl patch applicationset <appset-name> -n argocd --type='json' -p='[{"op":"remove","path":"/metadata/finalizers"}]'

# Force synchronization of all ApplicationSets
kubectl get applicationsets -n argocd -o name | xargs -I{} kubectl patch {} -n argocd --type=merge -p '{"spec":{"syncPolicy":{"preserveResourcesOnDeletion":false}}}'
```

## Managing Application Health

### Check Application Health

```bash
# Get health status of all applications
kubectl get applications -n argocd -o jsonpath='{range .items[*]}{.metadata.name}{": "}{.status.health.status}{"\n"}{end}'

# Get detailed health for a specific application
kubectl get application <app-name> -n argocd -o jsonpath='{.status.health}' | jq
```

### Forcing Application Refresh

```bash
# Patch to force refresh
kubectl patch application <app-name> -n argocd --type=merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'
```

## Bulk Operations

### Sync All Out-of-Sync Applications

```bash
kubectl get applications -n argocd --no-headers | grep OutOfSync | awk '{print $1}' | xargs -I{} kubectl patch application {} -n argocd --type=merge -p '{"metadata":{"annotations":{"argocd.argoproj.io/refresh":"hard"}}}'
```

### Delete All Applications in a Project

```bash
kubectl get applications -n argocd -l argocd.argoproj.io/project=<project-name> -o name | xargs kubectl delete -n argocd
```

## Advanced Management

### Managing Resources Outside the Cluster

For applications tracking resources outside the current cluster:

```bash
# Check destination server
kubectl get application <app-name> -n argocd -o jsonpath='{.spec.destination.server}'

# Change destination server
kubectl patch application <app-name> -n argocd --type=merge -p '{"spec":{"destination":{"server":"https://kubernetes.default.svc"}}}'
```

### Handling Application Drift

To address configuration drift in resources:

```bash
# Enable auto-sync with pruning and self-healing
kubectl patch application <app-name> -n argocd --type=merge -p '{"spec":{"syncPolicy":{"automated":{"prune":true,"selfHeal":true}}}}'
```

## Best Practices

1. **Use ApplicationSets**: Instead of managing individual Applications, use ApplicationSets for templating and bulk management
2. **Implement Projects**: Use ArgoCD Projects to establish boundaries and permissions for applications
3. **Establish Sync Windows**: For production environments, define sync windows to control when automatic syncs can occur
4. **Monitor Resource Health**: Configure appropriate health checks for your resources
5. **Use Labels**: Apply consistent labeling to applications for easier filtering and bulk operations
6. **Set Resource Tracking Method**: Define the appropriate tracking method (annotation, label, or name) for your deployment strategy

## See Also

- [ArgoCD Troubleshooting](./troubleshooting.md)
- [Working with Finalizers](../resource-management/finalizers.md)
- [Namespace Management](../namespace-management/index.md)